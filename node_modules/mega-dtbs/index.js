
var fs = require('fs'),
    path = require("path")

let globalDB;
let directorio = path.dirname(require.main.filename).split("/");

let send_message = false


//esto verifica la estructura de glitch y el path sub-directorios, evitamos hacer esto con .assets pero este package solo es de prueba.
for(var x = 0; x < directorio.length; x++) {
  if(fs.existsSync(directorio.join("/")+"/node_modules")) {
    directorio = directorio.join("/")
    break
  }
  directorio = directorio.slice(0, -1)
}


try{
globalDB = JSON.parse(fs.readFileSync(`${directorio}/mega_db.json`, 'utf8'));
}
catch(error){
fs.writeFileSync(`${directorio}/mega_db.json`, JSON.stringify({}, null, 2));
globalDB = JSON.parse(fs.readFileSync(`${directorio}/mega_db.json`, 'utf8'));
}


function Save_data() {
fs.writeFileSync(`${directorio}/mega_db.json`, JSON.stringify(globalDB, null, 2));
}


module.exports = {

  /*
  funciones:
    - crearDB
    - agregar
    - obtener
    - tiene
    - eliminar
    - push
    - extract
    - sumar
    - restar
    - datos
    - ordenar
  */

  //funcion para inicializar, crear o obtener un db existente.
  crearDB: function(db_name) {
    if(!db_name) throw new TypeError("Nombre del database no especificado")
    if(typeof db_name != "string") throw new TypeError("El nombre del database debe ser un string (cadena de texto).")
    if(db_name.includes(" ")) throw new TypeError("El nombre del database no debe de contener espacios en blanco ni puntos.")
    if(send_message == false) {
      send_message = true
      console.log("[IMPORTANT MESSAGE] The mega-dtbs package is outdated, please use the new version: https://www.npmjs.com/package/megadb")
      console.log("[MENSAJE IMPORTANTE] El package mega-dtbs esta desactualizado, por favor usar la nueva version: https://www.npmjs.com/package/megadb")
    }

    this.key = db_name
    this.value = function(key_value) {
      if(globalDB[key_value]) {
        return globalDB[key_value].value
      }else{
        globalDB[key_value] = {
          value: {}
        }
        Save_data()
        return globalDB[key_value].value
      }
    }(db_name),

    //funcion para agregar datos al db, tambien detecta y agrega propiedades no existentes al db automaticamente a travez del punto.
    this.agregar = function(key_value, type_value) {
      if(!key_value) throw new TypeError("Clave no especificada.")
      if(key_value.includes(" ")) throw new TypeError("Formato invalido, no pongas espacios.")
      if(typeof key_value != "string") throw new TypeError("Formato invalido, debes de poner un string (cadena de texto).")
      if (!type_value && type_value != 0) throw new TypeError("Valor no especificado.")

      return new Promise((resolve, reject) => {
        if(key_value.includes(".")) {
          let result = this.value
          let global_object = result;
          let split_coords = key_value.split(".")
          let set_value = type_value
          if(split_coords.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco, tampoco usar dos puntos uno seguido de otro.")


          for(var x = 0; x < split_coords.length; x++) {
            let objecT_name = split_coords[x]
            if(global_object[objecT_name]) {
              if(x == split_coords.length - 1) global_object = global_object[objecT_name] = set_value
              //else global_object = typeof global_object[objecT_name] != "object" ? global_object[objecT_name] = {} : global_object[objecT_name]
              else global_object = (Array.isArray(global_object[objecT_name]) || typeof global_object[objecT_name] != "object") ? global_object[objecT_name] = {} : global_object[objecT_name]
            }else{
              if(x == split_coords.length - 1) global_object = global_object[objecT_name] = set_value
              else global_object = global_object[objecT_name] = {}
            }
          }
          Save_data()
          resolve(this.value[split_coords[0]])
        }
        else{
          if(this.value[key_value] != null) {
            this.value[key_value] = type_value
            Save_data()
            resolve(this.value[key_value])
          }
          else{
            this.value[key_value] = type_value
            Save_data()
            resolve(this.value[key_value])
          }
        }
      })
    },

    //funcion para obtener datos del db, tambien detecta propiedades a travez del punto para obtener algo especifico.
    this.obtener = function(values) {
      if(!values) throw new TypeError("Clave no especificada")
      if(typeof values != "string") throw new TypeError("Formato invalido, debes de poner un string (cadena de texto).")
      if(values.includes(" ")) throw new TypeError("Formato invalido, no pongas espacios.")

      return new Promise((resolve, reject) => {
        if(values.includes(".")) {
          let properties = values.split(".")
          if(properties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco, tampoco usar dos puntos uno seguido de otro.")

          let lastobject = this.value
          for(var x = 0; x < properties.length; x++) {
            let index = properties[x]
            if(lastobject[index] != null) {
              lastobject = lastobject[index]
              if(x === properties.length - 1) resolve(lastobject)
            }else{
              reject(null)
            }
          }
        }
        else{
          if(this.value[values] != null) {
            resolve(this.value[values])
          }
          else{
            reject(null)
          }
        }
      })
    },

    //funcion para detectar datos del db, tambien detecta propiedades a travez del punto para verificar algo especifico.
    this.tiene = function(values) {
      if(!values) throw new TypeError("Clave no especificada")
      if(typeof values != "string") throw new TypeError("Formato invalido, debes de poner un string (cadena de texto).")
      if(values.includes(" ")) throw new TypeError("Formato invalido, no pongas espacios.")

      if(values.includes(".")) {
        let properties = values.split(".")
        if(properties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco, tampoco usar dos puntos uno seguido de otro.")

        let lastobject = this.value
        for(var x = 0; x < properties.length; x++) {
          let index = properties[x]
          if(lastobject[index] != null) {
            lastobject = lastobject[index]
            if(x === properties.length - 1) return true
          }else{
            return false
          }
        }
      }
      else{
        if(this.value[values] != null) {
          return true
        }
        else{
          return false
        }
      }
    },

    //funcion para eliminar datos del db, tambien detecta propiedades a travez del punto para elimina algo especifico.
    this.eliminar = function(key_value) {
      if(!key_value) {
        throw new TypeError("Clave no especificada")
      }else{
        if(typeof key_value != "string") throw new TypeError("Formato invalido, debes de poner un string (cadena de texto).")
        if(key_value.includes(" ")) throw new TypeError("Formato invalido, no pongas espacios.")
        if(key_value.includes(".")) {
          let properties = key_value.split(".")
          if(properties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco, tampoco usar dos puntos uno seguido de otro.")

          let lastobject = this.value
          for(var x = 0; x < properties.length; x++) {
            let index = properties[x]
            if(lastobject[index] != null) {
              if(x === properties.length - 1) {
                delete lastobject[index]
                Save_data()
                return true
              }

              lastobject = lastobject[index]

            }else{
              return false
            }
          }
        }
        else{
          if(this.value[key_value] != null) {
            delete this.value[key_value]
            Save_data()
            return true
          }
          return false
        }
      }
    },

    //funcion para retornar todos los datos de un database.
    this.datos = function(){
      return new Promise((resolve, reject) => {
        if(this.value != null) {
          resolve(this.value)
        }
        reject(null)
      })
    },

    //funcion para agregar un elemento a una lista, tambien detecta propiedades a travez del punto y agrega elementos a algo especifico.
    this.push = function(key_value, type_value) {
      if(!key_value) throw new TypeError("Clave no especificada")
      if (!type_value && type_value != 0) throw new TypeError("Valor no especificado.")
      if(typeof key_value != "string") throw new TypeError("Formato invalido, debes de poner un string (cadena de texto).")

      if(key_value.includes(" ")) throw new TypeError("Formato invalido, no pongas espacios.")

      return new Promise((resolve, reject) => {

        if(key_value.includes(".")) {
          let properties = key_value.split(".")
          if(properties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco, tampoco usar dos puntos uno seguido de otro.")

          let lastobject = this.value
          for(var x = 0; x < properties.length; x++) {
            let index = properties[x]
            if(lastobject[index] != null) {
              lastobject = lastobject[index]
              if(x === properties.length - 1) {
                if(Array.isArray(lastobject)) {
                  lastobject.push(type_value)
                  Save_data()
                  resolve(lastobject)
                }
                else{
                  reject("Array no encontrado.")
                }
              }
            }else{
              reject("Array no encontrado.")
            }
          }
        }
        else{
          if(this.value[key_value] != null) {
            if(Array.isArray(this.value[key_value])) {
              this.value[key_value].push(type_value)
              Save_data()
              resolve(this.value[key_value])
            }
            else{
              reject("Array no encontrado.")
            }

          }
          else{
            reject("Array no encontrado.")
          }
        }
      })
    },

    //funcion para eliminar un elemento de una lista (array), tambien detecta propiedades a travez del punto y elimina elementos de algo especifico.
    this.extract = function(key_value, type_value) {
      if(!key_value) throw new TypeError("Clave no especificada")
      if (!type_value && type_value != 0) throw new TypeError("Valor no especificado.")
      if(typeof key_value != "string") throw new TypeError("Formato invalido, debes de poner un string (cadena de texto).")

      if(key_value.includes(" ")) throw new TypeError("Formato invalido, no pongas espacios.")

      return new Promise((resolve, reject) => {

        if(key_value.includes(".")) {
          let properties = key_value.split(".")
          if(properties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco, tampoco usar dos puntos uno seguido de otro.")

          let lastobject = this.value
          for(var x = 0; x < properties.length; x++) {
            let index = properties[x]
            if(lastobject[index] != null) {
              lastobject = lastobject[index]
              if(x === properties.length - 1) {
                if(Array.isArray(lastobject)) {
                  if(lastobject.includes(type_value)) {
                    lastobject.splice(lastobject.indexOf(type_value), 1)
                    Save_data()
                    resolve(lastobject)
                  }else{
                    reject(`Elemento ${type_value} no encontrado.`)
                  }
                }
                else{
                  reject("Array no encontrado.")
                }
              }
            }else{
              reject("Array no encontrado.")
            }
          }
        }
        else{
          if(this.value[key_value] != null) {
            if(Array.isArray(this.value[key_value])) {
              if(this.value[key_value].includes(type_value)) {
                this.value[key_value].splice(this.value[key_value].indexOf(type_value), 1)
                Save_data()
                resolve(this.value[key_value])
              }else{
                reject(`Elemento ${type_value} no encontrado.`)
              }
            }
            else{
              reject("Array no encontrado.")
            }

          }
          else{
            reject("Array no encontrado.")
          }
        }
      })

    },
    //funcion para restar una cierta cantidad a un valor, tambien puedes acceder a un valor especifico.
    this.restar = function(key_value, type_value) {
      if(!key_value) throw new TypeError("Clave no especificada")
      if (!type_value && type_value != 0) throw new TypeError("Valor no especificado.")
      if(typeof key_value != "string") throw new TypeError("Formato invalido, debes de poner un string (cadena de texto).")
      if(typeof type_value != "number") throw new TypeError("Formato invalido, debes de poner un numero.")
      if(key_value.includes(" ")) throw new TypeError("Formato invalido, no pongas espacios.")
      return new Promise((resolve, reject) => {

        if(key_value.includes(".")) {
          let properties = key_value.split(".")
          if(properties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco, tampoco usar dos puntos uno seguido de otro.")

          let lastobject = this.value
          for(var x = 0; x < properties.length; x++) {
            let index = properties[x]
            if(lastobject[index] != null) {
              if(x === properties.length - 1) {
                if(!isNaN(lastobject[index])) {
                  lastobject[index] = lastobject[index] - type_value
                  Save_data()
                  resolve(lastobject[index])
                }
                else{
                  reject("Numero no encontrado.")
                }
              }

              lastobject = lastobject[index]

            }
            else{
              reject("Numero no encontrado.")
            }
          }
        }
        else{
          if(this.value[key_value] != null) {
            if(!isNaN(this.value[key_value])) {
              this.value[key_value] = this.value[key_value] - type_value
              Save_data()
              resolve(this.value[key_value])
            }
            else{
              reject("Numero no encontrado.")
            }

          }
          else{
            reject("Numero no encontrado.")
          }
        }
      })

    },

    //funcion para sumar una cierta cantidad a un valor, tambien puedes acceder a un valor especifico.
    this.sumar = function(key_value, type_value) {
      if(!key_value) throw new TypeError("Clave no especificada")
      if (!type_value && type_value != 0) throw new TypeError("Valor no especificado.")
      if(typeof key_value != "string") throw new TypeError("Formato invalido, debes de poner un string (cadena de texto).")
      if(typeof type_value != "number") throw new TypeError("Formato invalido, debes de poner un numero.")
      if(key_value.includes(" ")) throw new TypeError("Formato invalido, no pongas espacios.")
      return new Promise((resolve, reject) => {

        if(key_value.includes(".")) {
          let properties = key_value.split(".")
          if(properties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco, tampoco usar dos puntos uno seguido de otro.")

          let lastobject = this.value
          for(var x = 0; x < properties.length; x++) {
            let index = properties[x]
            if(lastobject[index] != null) {
              if(x === properties.length - 1) {
                if(!isNaN(lastobject[index])) {
                  lastobject[index] = lastobject[index] + type_value
                  Save_data()
                  resolve(lastobject[index])
                }
                else{
                  reject("Numero no encontrado.")
                }
              }

              lastobject = lastobject[index]

            }
            else{
              reject("Numero no encontrado.")
            }
          }
        }
        else{
          if(this.value[key_value] != null) {
            if(!isNaN(this.value[key_value])) {
              this.value[key_value] = this.value[key_value] + type_value
              Save_data()
              resolve(this.value[key_value])
            }
            else{
              reject("Numero no encontrado.")
            }

          }
          else{
            reject("Numero no encontrado.")
          }
        }
      })

    },
    //esta funcion te permite ordenar valores, tambien de permite actualizar propiedades especificas usando el .
    this.ordenar = function(key_value, type_value) {
      if(!key_value && key_value != false) throw new TypeError("Clave no especificada.")
      if(key_value != false && typeof key_value != "string") throw new TypeError("Formato invalido, la clave debes de ser un string (cadena de texto) o false en caso de que no busques propiedades.")
      if (!type_value && type_value != false && type_value != 0) throw new TypeError("Valor no especificado.")


      return new Promise((resolve, reject) => {

        if(key_value == false) {
          //si la clave es false        
          if(type_value == false) {
            //si el valor es false y no es un objeto
            let final_array = []
            for(var key in this.value) {
              if(typeof this.value[key] != "number") reject("Los valores no son numeros.")
              final_array.push({clave: key, valor: this.value[key]})
            }
            final_array.sort(function (a,b) {
              return b.valor - a.valor
            })
            resolve(final_array)
          }
          else{
            //si el valor no es false y es un objeto
            if(typeof type_value != "string") throw new TypeError("Formato invalido, el valor debe ser un string (cadena de texto) o false en caso de que no busques propiedades.")
            if(type_value.includes(".")) {
              //si el valor incluye propiedades
              let properties = type_value.split(".")
              if(properties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco en la clave, tampoco usar dos puntos uno seguido de otro.")

              let final_array = []
              for(var key1 in this.value) {

                let lastobject = this.value[key1]

                for(var x = 0; x < properties.length; x++) {
                  let index = properties[x]
                  if(lastobject[index] != null) {
                    if(x === properties.length - 1) {
                      if(typeof lastobject[index] != "number") reject("Los valores no son numeros.")
                      final_array.push({clave: key1, valor: lastobject})
                    }
      
                    lastobject = lastobject[index]
      
                  }
                  else{
                    reject(null)
                  }
                }
              }
              
              final_array.sort(function (a,b) {
                return b.valor[properties[properties.length - 1]] - a.valor[properties[properties.length - 1]]
              })
              resolve(final_array)

            }
            else{
              //si el valor no incluye propiedades
              let final_array = []
              for(var key in this.value) {
                if(typeof this.value[key][type_value] != null) {
                  if(typeof this.value[key][type_value] != "number") reject("Los valores no son numeros.")
                  final_array.push({clave: key, valor: this.value[key]})
                }
                else{
                  reject(null)
                }
              }

              final_array.sort(function (a,b) {
                return b.valor[type_value] - a.valor[type_value]
              })
              resolve(final_array)
            }
          }
        }
        else{ 
          //si la clave no es false
          if(type_value == false) {
            //si el valor es false
            if(key_value.includes(".")) {
              //si la clave contiene propiedades

              let properties = key_value.split(".")
              if(properties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco en la clave, tampoco usar dos puntos uno seguido de otro.")

              let final_array = []
              let lastobject = this.value

              for(var x = 0; x < properties.length; x++) {
                let index = properties[x]
                if(lastobject[index] != null) {
                  lastobject = lastobject[index]
                  if(x === properties.length - 1) {
                    for(var key in lastobject) {
                      
                      if(lastobject[key] != null) {
                        if(typeof lastobject[key] != "number") reject("Los valores no son numeros.")
                        final_array.push({clave: key, valor: lastobject[key]})
                      }
                      else{
                        reject(null)
                      }
                    }
                  }     
                }
                else{
                  reject(null)
                }
              }

              final_array.sort(function (a,b) {
                return b.valor - a.valor
              })
              resolve(final_array)
            }
            else{
              //si la clave no contiene propiedades
              let final_array = []
              let lastobject = this.value[key_value]
              for(var key in lastobject) {
                if(lastobject[key] != null) {
                  if(typeof lastobject[key] != "number") reject("Los valores no son numeros.")
                  final_array.push({clave: key, valor: lastobject[key]})
                }
                else{
                  reject(null)
                }
              }

              final_array.sort(function (a,b) {
                return b.valor - a.valor
              })
              resolve(final_array)
            }
          }
          else{

            if(typeof type_value != "string") throw new TypeError("Formato invalido, la clave debe ser un string (cadena de texto) o false en caso de que no busques propiedades.")
            if(key_value.includes(".")) {
              //si la clave incluye propiedades
              let properties = key_value.split(".")
              if(properties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco en la clave, tampoco usar dos puntos uno seguido de otro.")
              
              if(type_value.includes(".")) {
                let final_array = []

                //si el valor incluye propiedades
                let valuerties = type_value.split(".")
                if(valuerties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco en la clave, tampoco usar dos puntos uno seguido de otro.")

                let lastobject = this.value
                
                for(var x = 0; x < properties.length; x++) {
                  let index = properties[x]
                  if(lastobject[index] != null) {
                    if(x === properties.length - 1) {
                      lastobject = lastobject[index]
                      for(var key in lastobject) {

                        let propobject = lastobject[key]
                        for(var y = 0; y < valuerties.length; y++) {
                          let index_2 = valuerties[y]
                          if(propobject[index_2] != null) {

                            if(y === valuerties.length - 1) {
                              
                              if(typeof propobject[index_2] != "number") reject("Los valores no son numeros.")
                              final_array.push({clave: key, valor: propobject})
                            }

                            propobject = propobject[index_2]
    
                          }
                          else{
                            reject(null)
                          }    
                        }
                      }
                    }
        
                    lastobject = lastobject[index]
        
                  }
                  else{
                      reject(null)
                  }
                }

                final_array.sort(function (a,b) {
                  return b.valor[valuerties[valuerties.length - 1]] - a.valor[valuerties[valuerties.length - 1]]
                })
                resolve(final_array)
              }
              else{
                //Si el valor no incluye propiedades
                let final_array = []

                let lastobject = this.value
                for(var x = 0; x < properties.length; x++) {
                  let index = properties[x]
                  if(lastobject[index] != null) {
                    lastobject = lastobject[index]
                    if(x === properties.length - 1) {                    
                      for(key in lastobject) {

                        if(lastobject[key][type_value] != null) {
                          if(typeof lastobject[key][type_value] != "number") reject("Los valores no son numeros.")
                          final_array.push({clave: key, valor: lastobject[key]})
                        }
                        else{
                          reject(null)
                        }
                      }
                    }                      
                  }
                  else{
                    reject(null)
                  }
                }

                final_array.sort(function (a,b) {
                  return b.valor[type_value] - a.valor[type_value]
                })
                resolve(final_array)
              }
            }
            else{
              //si la clave no incluye propiedades
              if(type_value.includes(".")){
                //si el valor incluye propiedades
                let final_array = []
                let valuerties = type_value.split(".")
                if(valuerties.some(r => r.length <= 0)) throw new TypeError("Formato invalido, asegurate de no poner espacios en blanco en la clave, tampoco usar dos puntos uno seguido de otro.")

                if(this.value[key_value] != null) {
                  let lastobject = this.value[key_value]
                  for(var key in lastobject) {

                    let propobject = lastobject[key]

                    for(var x = 0; x < valuerties.length; x++) {
                      let index = valuerties[x]
                      if(propobject[index] != null) {
                
                        if(x === valuerties.length - 1) {
                          if(typeof propobject[index] != "number") reject("Los valores no son numeros.")
                          final_array.push({clave: key, valor: propobject})                                    
                        }

                        propobject = propobject[index]

                      }
                      else{
                        reject(null)
                      }
                    }
                  }
                }
                else{
                  reject(null)
                }

                final_array.sort(function (a,b) {
                  return b.valor[valuerties[valuerties.length - 1]] - a.valor[valuerties[valuerties.length - 1]]
                })
                resolve(final_array)

              }
              else{
                //si el valor no incluye propiedades
                let final_array = []
                if(this.value[key_value] != null) {
                  let lastobject = this.value[key_value]
                  for(var key in lastobject) {
                    if(lastobject[key][type_value] != null) {
                      if(typeof lastobject[key][type_value] != "number") reject("Los valores no son numeros.")
                      final_array.push({clave: key, valor: lastobject[key]})
                    }
                    else{
                      reject(null)
                    }
                  }
                }
                else{
                  reject(null)
                }

                final_array.sort(function (a,b) {
                  return b.valor[type_value] - a.valor[type_value]
                })

                resolve(final_array)

              }
            }         
          }
        }
      });
    }
  }
}

